Estoy creando un analisador sintactico con SLR(0) en python  esta es la implementacion para el automata de SLR(0) 
class LR0Item:
    def __init__(self, production, position,derived=False):
        self.production = (production[0], tuple(production[1]))
        self.position = position
        self.derived = derived

    def __repr__(self):
        return f'{self.production[0]} -> {" ".join(self.production[1][:self.position]) + "•" + " ".join(self.production[1][self.position:])}'

    def __eq__(self, other):
        return self.production == other.production and self.position == other.position

    def __hash__(self):
        return hash((self.production, self.position))


def closure(items, productions):
    new_items = set(items)
    changed = True
    while changed:
        changed = False
        for item in list(new_items):
            if item.position < len(item.production[1]) and item.production[1][item.position] in productions:
                non_terminal = item.production[1][item.position]
                for production in productions[non_terminal]:
                    new_item = LR0Item((non_terminal, production), 0,True)
                    if new_item not in new_items:
                        new_items.add(new_item)
                        changed = True
    return new_items


def goto(items, symbol, productions):
    next_items = set()
    for item in items:
        if item.position < len(item.production[1]) and item.production[1][item.position] == symbol:
            next_items.add(LR0Item(item.production, item.position + 1))
    return closure(next_items, productions)

def canonical_collection(productions):
    items = LR0Item((list(productions.keys())[0]+'\'', [list(productions.keys())[0]]), 0)
    states = [closure({items}, productions)]
    stack = [states[0]]
    transitions = []

    while stack:
        print(states,'\n')
        print(transitions,'\n\n')
        state = stack.pop()
        for symbol in set(sym for item in state for sym in item.production[1][item.position:item.position + 1]):
            next_state = goto(state, symbol, productions)
            if not next_state:
                continue
            if next_state not in states:
                states.append(next_state)
                stack.append(next_state)
            transitions.append((states.index(state), symbol, states.index(next_state)))
    
    accept_state = len(states)
    for i,state in enumerate(states):
        for item in state:
            if item.production[0] == list(productions.keys())[0]+'\'' and item.position == len(item.production[1]) and item.derived == False:
                transitions.append((i,'$',accept_state))
                break
    states.append(set())

    return states, transitions
que devuelve lo siguiente

Estados:
0: {expression' -> •expression, term -> •factor, factor -> •ID, expression -> •expression PLUS term, term -> •term TIMES factor, factor -> •LPAREN expression RPAREN, expression -> •term}
1: {expression -> expression•PLUS term, expression' -> expression•}
2: {expression -> term•, term -> term•TIMES factor}
3: {term -> factor•}
4: {term -> •factor, factor -> •ID, expression -> •expression PLUS term, factor -> LPAREN•expression RPAREN, term -> •term TIMES factor, factor -> •LPAREN expression RPAREN, expression -> •term}
5: {factor -> ID•}
6: {expression -> expression•PLUS term, factor -> LPAREN expression•RPAREN}
7: {factor -> LPAREN expression RPAREN•}
8: {term -> •factor, factor -> •ID, term -> •term TIMES factor, expression -> expression PLUS•term, factor -> •LPAREN expression RPAREN}
9: {expression -> expression PLUS term•, term -> term•TIMES factor}
10: {term -> term TIMES•factor, factor -> •ID, factor -> •LPAREN expression RPAREN}
11: {term -> term TIMES factor•}
12: set()
Transiciones:
(0, 'expression', 1)
(0, 'term', 2)
(0, 'factor', 3)
(0, 'LPAREN', 4)
(0, 'ID', 5)
(4, 'expression', 6)
(4, 'term', 2)
(4, 'factor', 3)
(4, 'LPAREN', 4)
(4, 'ID', 5)
(6, 'RPAREN', 7)
(6, 'PLUS', 8)
(8, 'term', 9)
(8, 'factor', 3)
(8, 'ID', 5)
(8, 'LPAREN', 4)
(9, 'TIMES', 10)
(10, 'LPAREN', 4)
(10, 'factor', 11)
(10, 'ID', 5)
(2, 'TIMES', 10)
(1, 'PLUS', 8)
(1, '$', 12)
y aqui estan las implementaciones de las funciones foolow_pos y first_pos
def get_terminals_and_non_terminals(productions):
    non_terminals = set(productions.keys())
    terminals = set()

    for non_terminal in non_terminals:
        for production in productions[non_terminal]:
            for symbol in production:
                if symbol not in non_terminals:
                    terminals.add(symbol)

    return terminals, non_terminals


def first_sets(productions):
    terminals, non_terminals = get_terminals_and_non_terminals(productions)
    first = {non_terminal: set() for non_terminal in non_terminals}

    changed = True
    while changed:
        changed = False
        for non_terminal in non_terminals:
            for production in productions[non_terminal]:
                for symbol in production:
                    # Para cada terminal en la producción, añadirlo al conjunto first
                    if symbol in terminals:
                        if symbol not in first[non_terminal]:
                            first[non_terminal].add(symbol)
                            changed = True
                        break
                    # Si el símbolo es un no terminal, añadir su conjunto first al conjunto first actual
                    else:
                        added = len(first[non_terminal])
                        first[non_terminal].update(first[symbol] - {None})
                        if len(first[non_terminal]) != added:
                            changed = True
                        # Si el símbolo actual puede generar la cadena vacía (None), continuar con el siguiente símbolo
                        if None not in first[symbol]:
                            break
                else:
                    if None not in first[non_terminal]:
                        first[non_terminal].add(None)
                        changed = True

    return first


def follow_sets(productions, first_sets):
    _, non_terminals = get_terminals_and_non_terminals(productions)
    follow = {non_terminal: set() for non_terminal in non_terminals}
    follow[next(iter(non_terminals))].add('$')

    changed = True
    while changed:
        changed = False
        for non_terminal in non_terminals:
            for production in productions[non_terminal]:
                for i, symbol in enumerate(production):
                    if symbol in non_terminals:
                        # Si no es el último símbolo de la producción, añadir el conjunto first del siguiente símbolo
                        if i + 1 < len(production):
                            next_symbol = production[i + 1]
                            if next_symbol in non_terminals:
                                added = len(follow[symbol])
                                follow[symbol].update(first_sets[next_symbol] - {None})
                                if len(follow[symbol]) != added:
                                    changed = True
                            # Si el siguiente símbolo es un terminal, añadirlo al conjunto follow
                            else:
                                if next_symbol not in follow[symbol]:
                                    follow[symbol].add(next_symbol)
                                    changed = True
                        # Si es el último símbolo de la producción, añadir el conjunto follow del no terminal actual
                        else:
                            added = len(follow[symbol])
                            follow[symbol].update(follow[non_terminal])
                            if len(follow[symbol]) != added:
                                changed = True

    return follow
que devuelven esto 
First sets:
term: {'LPAREN', 'ID'}
factor: {'LPAREN', 'ID'}
expression: {'LPAREN', 'ID'}

Follow sets:
term: {'$', 'PLUS', 'RPAREN', 'TIMES'}
factor: {'$', 'PLUS', 'RPAREN', 'TIMES'}
expression: {'RPAREN', 'PLUS'}

Lo que necesito es que armes la tabla de análisis sintáctico SLR usando el siguiente metodo:
1. Construir C = { I0, I1, …, In }, la colección de conjuntos de elementos LR(0) para G'.
2. El estado i se construye a partir de Ii. Las acciones de análisis sintáctico para el estado i se determinan de la siguiente forma:
 (a) Si [A → α·aβ] está en Ii e ir_A(Ii, a) = Ij, entonces establecer ACCION[i, a] a “desplazar j”. Aquí, a debe ser una terminal.
 (b) Si [A → α·] está en Ii, entonces establecer ACCION[i, a] a “reducir A → α” para toda a en SIGUIENTE(A); aquí, A tal vez no sea S'
 (c) Si [S → S·] está en Ii, entonces establecer ACCION[i, $] a “aceptar”.
3. Las transiciones de ir_A para el estado i se construyen para todos los no terminales A,
usando la regla: Si ir_A(Ii, A) = Ij, entonces ir_A[i, A] = j.
4. Todas las entradas que no estén definidas por las reglas (2) y (3) se dejan como “error”.
5. El estado inicial del analizador sintáctico es el que se construyó a partir del conjunto de 
elementos que contienen [S' → ·S]

La tabla tiene que tener tanto las acciones de reducir marcadas como " R + estado al que va" y los desplazamientos como " S + estado al que va" 
Ademas de la tabla de las acciones tabien crea la tabla de ir_A

el reultado para la tabla de acciones deberia ser algo como esto

ACTION table:
Symbol      ID PLUS  TIMES  RPAREN  LPAREN       $
State
0           S5  NaN    NaN      S4     NaN     NaN
1          NaN   S6    NaN     NaN     NaN  ACCEPT
2          NaN   R2     S7     NaN      R2      R2
. . . 
11         NaN   R5     R5     NaN      R5      R5

y la tabla de ir_A buscaria algo como esto
ir_A table:
Symbol       E    T      F 
State
0            1    2      3
1          NaN  NaN    NaN
2          NaN  NaN    NaN  
. . . 
11         NaN  NaN    NaN 

